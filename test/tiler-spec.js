// Generated by CoffeeScript 1.10.0
(function() {
  var Tiler, debug, defer, expect;

  expect = require("chai").expect;

  Tiler = require('../lib/Tiler');

  defer = require('node-promise').defer;

  debug = process.env['DEBUG'];

  describe("Tiler test", function() {
    var cache, cacheEngine, modelEngine, storage, storageEngine, tiler;
    storage = {};
    cache = {};
    tiler = void 0;
    storageEngine = {
      find: function(type, prop, val) {
        var i, k, o, q, result, v;
        q = defer();
        result = void 0;
        for (i in storage) {
          o = storage[i];
          for (k in o) {
            v = o[k];
            if (k === prop && v === val) {
              result = o;
            }
          }
        }
        q.resolve(result);
        return q;
      },
      get: function(id) {
        var q;
        q = defer();
        q.resolve(storage[id]);
        return q;
      },
      set: function(id, obj) {
        var q;
        q = defer();
        storage[id] = obj;
        q.resolve();
        return q;
      }
    };
    cacheEngine = {
      get: function(id) {
        var q;
        q = defer();
        q.resolve(cache[id]);
        return q;
      },
      set: function(id, obj) {
        var q;
        q = defer();
        cache[id] = obj;
        q.resolve();
        return q;
      },
      getAllValuesFor: function(wildcard) {
        var k, q, rv, v;
        q = defer();
        rv = [];
        for (k in cache) {
          v = cache[k];
          if (k.indexOf(wildcard) > -1) {
            rv.push(v);
          }
        }
        q.resolve(rv);
        return q;
      }
    };
    modelEngine = {
      createZone: function(obj) {
        var q;
        obj.serialize = function() {
          return storageEngine.set(obj.id, obj);
        };
        q = defer();
        q.resolve(obj);
        return q;
      }
    };
    before(function(done) {
      tiler = new Tiler(storageEngine, cacheEngine, modelEngine);
      return done();
    });
    it("should be able to calculate zoneid for positive x,y", function(done) {
      var zid;
      zid = tiler.getZoneIdFor(1, 23, 25);
      expect(zid).to.equal('1_20_20');
      return done();
    });
    it("should be able to calculate zoneid for negative x,y", function(done) {
      var zid;
      zid = tiler.getZoneIdFor(1, -44, -4);
      expect(zid).to.equal('1_-40_0');
      return done();
    });
    it("should be able to calculate zoneid for mixed x,y", function(done) {
      var zid;
      zid = tiler.getZoneIdFor(1, 114, -294);
      expect(zid).to.equal('1_100_-280');
      return done();
    });
    it("should be able to resolve and create a new zone", function(done) {
      return tiler.resolveZoneFor(1, 114, -294).then(function(zoneObj) {
        expect(zoneObj.id).to.equal('1_100_-280');
        return done();
      });
    });
    it("should be able to resolve an old, existing zone", function(done) {
      return tiler.resolveZoneFor(1, 114, -294).then(function(zoneObj) {
        expect(zoneObj.id).to.equal('1_100_-280');
        return done();
      });
    });
    it("should be able set a tile", function(done) {
      return tiler.setTileAt(1, {
        id: 'foo',
        type: 'bar',
        x: 79,
        y: 94
      }).then(function() {
        return tiler.resolveZoneFor(1, 79, 94).then(function(zoneObj) {
          expect(zoneObj.tiles['79_94']).to.exist;
          return done();
        });
      });
    });
    it("should be able get a tile", function(done) {
      return tiler.getTileAt(1, 79, 94, {
        id: 'foo'
      }).then(function(tile) {
        expect(tile.id).to.equal('foo');
        return done();
      });
    });
    it("should be able set multiple tiles at once", function(done) {
      var tiles;
      tiles = [
        {
          x: 10,
          y: 10,
          type: 1,
          ore: 1,
          stone: 1,
          features: []
        }, {
          x: 11,
          y: 10,
          type: 1,
          ore: 1,
          stone: 1,
          features: []
        }, {
          x: 12,
          y: 10,
          type: 1,
          ore: 1,
          stone: 1,
          features: []
        }
      ];
      return tiler.setAndPersistTiles(1, tiles).then(function(tiles) {
        expect(tiles.length).to.equal(3);
        return done();
      });
    });
    it("should be able to fail when setting faulty tile", function(done) {
      return tiler.setTileAt(1, {
        id: 'foo',
        type: 0,
        x: 1179,
        y: 1194
      }).then(function() {
        return console.log('setTile OK');
      }, function(reject) {
        expect(reject).to.exist;
        return done();
      });
    });
    it("should be able to add an item", function(done) {
      var item;
      item = {
        name: 'item 1',
        x: 30,
        y: 40,
        height: 1,
        width: 1
      };
      return tiler.addItem(1, item).then(function() {
        return tiler.resolveZoneFor(1, 30, 40).then(function(zoneObj) {
          var addedItem, itemQT;
          itemQT = tiler.zoneItemQuadTrees[zoneObj.tileid];
          addedItem = itemQT.retrieve({
            x: 30,
            y: 40
          });
          expect(addedItem).to.exist;
          return done();
        });
      });
    });
    it("should be able to get an item", function(done) {
      return tiler.getItemAt(1, 30, 40).then(function(item) {
        expect(item).to.exist;
        return done();
      });
    });
    return it("should be able remove an item", function(done) {
      var item;
      item = {
        name: 'item 1',
        x: 30,
        y: 40,
        height: 1,
        width: 1
      };
      return tiler.removeItem(1, item).then(function(result) {
        return tiler.getItemAt(1, 30, 40).then(function(olditem) {
          expect(olditem).to.not.exist;
          return done();
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=tiler-spec.js.map
