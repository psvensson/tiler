// Generated by CoffeeScript 1.9.3
(function() {
  var LRU, PriorityQueue, TilerReplication, debug, defer,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  defer = require('node-promise').defer;

  LRU = require('lru-cache');

  PriorityQueue = require('priorityqueue');

  debug = process.env["DEBUG"];

  "\nThe zone replica with the earliest timestamp (start-time) will act as master for the zone\n\nThe only thing the master does is persist the state each 60s (or so) of the zone, which also starts a new oplog epoch\n\nIf no new oplog epoch has been started in 120s (or so) then the next earliest timestamp replica will act as master.\n\nThe master is not elected, so if there are three replicas, and all but the lastest one goes off-line, that replica will wait for\n3x60s before it persists the zone.\n\nWhen one replica suspects another of being off-line, it will engage in reoeated polling and will remove the replica from the\nlist of siblings for the zone after 5 retries (with 2000ms spacing), this will result in a fairly stateless replica management.\n\nBefore a replica master for a zone persist, it sends out a new epoch command to all replicas, which will be the array, keyed by epoch timestamp (in a hashtable)\nwhere every replica stores operations made on the zone. All action results in operations and will be sent from the originating replica to all others. All will store\nthe operations in the same way under the same key.\n\nWhen a new replica for a zone goes on-line, it will send a join command to any of the replicas, and then start to load the zone from persistent storage.\nThe replica receiving the command will send over the oplog for the current epoch of the zone to the newly joining replica.\n\nThe new replica will be able to see all the addresses of all other zone replicas through the global cache system (redis or pubsub equiv) and all other replicas\nwill directly start sending any new operations for the current epoch to the new replica.\n\nWhen the replica have loaded the persistent state of the zone and applied all operations sent for the current epoch ,and after that applied all incoming operations that\nwas sent as part of normal operations from all other replica members, then it will be considering itself synchronized and will open for operations itself.\n";

  TilerReplication = (function() {
    TilerReplication.CMD_NEW_OPLOG_EPOCH = 'newEpoch';

    TilerReplication.CMD_GET_OPLOG = 'getOplog';

    TilerReplication.TIME_BETWEEN_MASTER_SAVES = 10 * 60 * 1000;

    TilerReplication.TIME_BETWEEN_IMALIVE = 1000;

    TilerReplication.REPLICA_REGISTRATION_EXPIRATION = 5000;

    TilerReplication.NUMBER_OF_DEFERS_TO_OLDER_REPLICAS = 3;

    TilerReplication.prototype.options = {
      max: 500,
      maxAge: TilerReplication.TIME_BETWEEN_MASTER_SAVES * 3
    };

    function TilerReplication(myAddress, cacheEngine, communicationManager) {
      this.myAddress = myAddress;
      this.cacheEngine = cacheEngine;
      this.communicationManager = communicationManager;
      this.getAndExecuteAllOutstandingCommands = bind(this.getAndExecuteAllOutstandingCommands, this);
      this.saveZone = bind(this.saveZone, this);
      this.weAreOldestReplicaFor = bind(this.weAreOldestReplicaFor, this);
      this.registerOurselvesAsMasterFor = bind(this.registerOurselvesAsMasterFor, this);
      this.checkMasterReplicaFor = bind(this.checkMasterReplicaFor, this);
      this.imalive = bind(this.imalive, this);
      this.setOurselvesAsReplica = bind(this.setOurselvesAsReplica, this);
      this.getAnyOtherSiblingsForZone = bind(this.getAnyOtherSiblingsForZone, this);
      this.getSiblingsForZone = bind(this.getSiblingsForZone, this);
      this.getOplogFor = bind(this.getOplogFor, this);
      this.addCommandToOplog = bind(this.addCommandToOplog, this);
      this.deRegisterTimer = bind(this.deRegisterTimer, this);
      this.onSiblingUpdate = bind(this.onSiblingUpdate, this);
      this.registerTimer = bind(this.registerTimer, this);
      this.shutdown = bind(this.shutdown, this);
      this.oplogs = {};
      this.timers = {};
      this.replicas = {};
    }

    TilerReplication.prototype.shutdown = function(zoneObj) {
      var replica;
      console.log('shutting down local replica of zone ' + zoneObj.id);
      replica = this.replicas[zoneObj.id];
      clearInterval(replica.imalivetimer);
      if (replica.mastersave) {
        clearInterval(replica.mastersave);
      }
      this.cacheEngine["delete"]('zonereplica_' + zoneObj.tileid + ':' + this.myAddress);
      return this.replicas[zoneObj.id] = '';
    };

    TilerReplication.prototype.registerTimer = function(fun, arg, time, lookup) {
      if (!this.timers[lookup]) {
        this.timers[lookup] = setInterval((function(_this) {
          return function() {
            return fun(arg);
          };
        })(this), time);
        return fun(arg);
      }
    };

    TilerReplication.prototype.onSiblingUpdate = function(command, replyfunc) {
      var oplog;
      console.log('TilerReplication.onSiblingUpdate: ' + JSON.stringify(command));
      if (command.cmd === TilerReplication.CMD_GET_OPLOG) {
        console.log('oplog get in TilerReplication for modifedAt ' + command.arg1 + ' called');
        oplog = this.getOplogFor({
          modifiedAt: command.arg1
        });
        return replyfunc(oplog.toArray());
      }
    };

    TilerReplication.prototype.deRegisterTimer = function(lookup) {
      var l;
      l = this.timers[lookup];
      if (l) {
        return clearInterval(l);
      }
    };

    TilerReplication.prototype.addCommandToOplog = function(zoneObj, command) {
      var oplog;
      oplog = this.getOplogFor(zoneObj);
      command.timeStamp = Date.now();
      oplog.push(command);
      return this.oplogs[zoneObj.modifiedAt] = oplog;
    };

    TilerReplication.prototype.getOplogFor = function(zoneObj) {
      var rv;
      rv = this.oplogs[zoneObj.modifiedAt];
      if (!rv) {
        rv = new PriorityQueue({
          comparator: function(a, b) {
            var x;
            x = 0;
            if (a.timeStamp > b.timeStamp) {
              x = -1;
            }
            if (a.timeStamp < b.timeStamp) {
              x = 1;
            }
            return x;
          }
        });
      }
      return rv;
    };

    TilerReplication.prototype.getSiblingsForZone = function(zoneObj) {
      var q;
      q = defer();
      this.cacheEngine.getAllValuesFor('zonereplica_' + zoneObj.tileid + ':*').then((function(_this) {
        return function(replicaAddresses) {
          return q.resolve(replicaAddresses);
        };
      })(this));
      return q;
    };

    TilerReplication.prototype.getAnyOtherSiblingsForZone = function(zoneObj) {
      var q;
      q = defer();
      this.cacheEngine.getAllValuesFor('zonereplica_' + zoneObj.tileid + ':*').then((function(_this) {
        return function(replicaAddresses) {
          var adr, i, len, replica;
          adr = '-1';
          for (i = 0, len = replicaAddresses.length; i < len; i++) {
            replica = replicaAddresses[i];
            adr = replica.split(",")[0];
            if (adr !== _this.myAddress) {
              console.log('found an address ' + adr + ' that was other than mine: ' + _this.myAddress);
              break;
            }
          }
          return q.resolve(adr);
        };
      })(this));
      return q;
    };

    TilerReplication.prototype.setOurselvesAsReplica = function(zoneObj, kind) {
      if (kind == null) {
        kind = 'copy';
      }
      console.log('setting address ' + this.myAddress + ' to be replica type ' + kind + ' for zone ' + zoneObj.id);
      return this.cacheEngine.set('zonereplica_' + zoneObj.tileid + ':' + this.myAddress, this.myAddress + "," + Date.now() + "," + kind).then((function(_this) {
        return function() {
          var replica;
          _this.cacheEngine.expireat('zonereplica_' + zoneObj.tileid + ':' + _this.myAddress, TilerReplication.REPLICA_REGISTRATION_EXPIRATION);
          replica = _this.replicas[zoneObj.id];
          if (!replica) {
            replica = {
              kind: kind,
              timers: {}
            };
          }
          if (!replica.timers.imalivetimer) {
            replica.timers.imalivetimer = _this.registerTimer(_this.imalive, zoneObj, TilerReplication.TIME_BETWEEN_IMALIVE, 'imalive_for_' + zoneObj.id);
          }
          if (replica.kind === 'copy') {
            _this.checkMasterReplicaFor(zoneObj);
          }
          return _this.replicas[zoneObj.id] = replica;
        };
      })(this));
    };

    TilerReplication.prototype.imalive = function(zoneObj) {
      var replica;
      replica = this.replicas[zoneObj.id];
      return this.setOurselvesAsReplica(zoneObj, replica.kind);
    };

    TilerReplication.prototype.checkMasterReplicaFor = function(zoneObj) {
      var q, replica;
      console.log('TilerReplication.checkMasterReplicaFor called for: ' + zoneObj.id);
      q = defer();
      replica = this.replicas[zoneObj.id];
      if (!replica) {
        replica = {
          kind: 'copy',
          timers: {}
        };
      }
      this.replicas[zoneObj.id] = replica;
      this.getSiblingsForZone(zoneObj).then((function(_this) {
        return function(siblings) {
          var master;
          if (siblings.length === 0) {
            _this.registerOurselvesAsMasterFor(zoneObj, siblings);
            return q.resolve(true);
          } else {
            master = false;
            siblings.forEach(function(sibling) {
              var arr;
              console.log('checkMasterReplice sibling -> ' + sibling);
              arr = sibling.split(',');
              console.dir(arr);
              if (arr[2] && arr[2] === 'master') {
                return master = true;
              }
            });
            if (!master) {
              _this.registerOurselvesAsMasterFor(zoneObj, siblings);
              return q.resolve(true);
            } else {
              return q.resolve(false);
            }
          }
        };
      })(this));
      return q;
    };

    TilerReplication.prototype.registerOurselvesAsMasterFor = function(zoneObj, siblings) {
      var ex, replica;
      console.log('TilerReplication.registerOurselvesAsMasterFor called for zone: ' + zoneObj.id);
      replica = this.replicas[zoneObj.id];
      if (siblings.length < 2 || this.weAreOldestReplicaFor(zoneObj, siblings)) {
        console.log('replica ' + this.myAddress + ' registering as master for replica ' + zoneObj.id);
        try {
          replica.kind = 'master';
          this.setOurselvesAsReplica(zoneObj, 'master');
          return replica.timers.mastersave = this.registerTimer(this.saveZone, zoneObj, TilerReplication.TIME_BETWEEN_MASTER_SAVES, 'master_saves_for_' + zoneObj.id);
        } catch (_error) {
          ex = _error;
          console.log('exception caught: ' + ex);
          console.dir(ex);
          return xyzzy;
        }
      } else {
        return console.log('we are not oldest replica. Deferring...');
      }
    };

    TilerReplication.prototype.weAreOldestReplicaFor = function(zoneObj, siblings) {
      var oldestSibling, rv, watch, we;
      rv = false;
      watch = zoneObj._masterWatch || 0;
      oldestSibling = 0;
      we = 0;
      siblings.forEach((function(_this) {
        return function(sibling) {
          var arr;
          arr = sibling.split(',');
          if (arr[1] > oldestSibling) {
            oldestSibling = arr[1];
          }
          if (arr[0] === _this.myAddress) {
            return we = arr[1];
          }
        };
      })(this));
      if (we === oldestSibling || watch > TilerReplication.NUMBER_OF_DEFERS_TO_OLDER_REPLICAS) {
        rv = true;
      }
      zoneObj._masterWatch = ++watch;
      return rv;
    };

    TilerReplication.prototype.saveZone = function(zoneObj) {
      return zoneObj.serialize().then((function(_this) {
        return function(zo) {
          var command;
          command = {
            cmd: TilerReplication.CMD_NEW_OPLOG_EPOCH,
            arg1: zoneObj.modifiedAt
          };
          return _this.getSiblingsForZone(zoneObj).then(function(siblings) {
            return siblings.forEach(function(sibling) {
              var adr;
              adr = sibling.split(',')[0];
              if (adr !== _this.myAddress) {
                console.log('master ' + _this.myAddress + ' for zone ' + zoneObj.id + ' sends out newEpoch command to copy replica ' + adr + ' after zone save');
                return _this.communicationManager.sendFunction(adr, command).then(function(reply) {});
              }
            });
          });
        };
      })(this));
    };

    TilerReplication.prototype.getAndExecuteAllOutstandingCommands = function(zoneObj, peerAddress) {
      var q;
      q = defer();
      this.setOurselvesAsReplica(zoneObj);
      this.getAnyOtherSiblingsForZone(zoneObj).then((function(_this) {
        return function(adr) {
          var command;
          command = {
            cmd: TilerReplication.CMD_GET_OPLOG,
            arg1: zoneObj.modifiedAt
          };
          if (adr !== '-1') {
            console.log('TilerReplication.getAndExecuteAllOutstandingCommands sending command from us (' + _this.myAddress + ')  to sibling ' + adr);
            return _this.communicationManager.sendFunction(adr, command).then(function(reply) {
              var oplog;
              console.log('got OPLOG reply from sibling: ' + JSON.stringify(reply));
              oplog = _this.getOplogFor(zoneObj);
              reply.forEach(function(oplogcmd) {
                console.log('*** OPLOG restoration at ' + _this.myAddress + ' from remote source ' + adr + ' : ' + JSON.stringify(oplogcmd));
                return _this.communicationManager.sendFunction(_this.myAddress, oplogcmd);
              });
              console.log('getAndExecuteAllOutstandingCommands done');
              return q.resolve();
            });
          } else {
            console.log('getAndExecuteAllOutstandingCommands done 2');
            return q.resolve();
          }
        };
      })(this));
      return q;
    };

    return TilerReplication;

  })();

  module.exports = TilerReplication;

}).call(this);

//# sourceMappingURL=TilerReplication.js.map
