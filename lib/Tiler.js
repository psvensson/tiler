// Generated by CoffeeScript 1.9.3
(function() {
  var BAD_TILE, QuadTree, Siblings, TILE_SIDE, Tiler, all, debug, defer, lru, lruopts,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  QuadTree = require('area-qt');

  defer = require('node-promise').defer;

  all = require('node-promise').allOrNone;

  lru = require('lru');

  Siblings = require('./TilerSiblings');

  debug = process.env["DEBUG"];

  lruopts = {
    max: 1000,
    maxAgeInMilliseconds: 1000 * 60 * 60 * 24 * 4
  };

  TILE_SIDE = 20;

  BAD_TILE = {
    x: 0,
    y: 0,
    type: -1,
    ore: -1,
    stone: -1,
    features: []
  };

  "TODO:\n1. Add support for manipulating items and entities\n2. Detect and manage siblings through cacheEngine\n3. Replicate tile, item and entity updates to siblings";

  Tiler = (function() {
    function Tiler(storageEngine, cacheEngine, modelEngine, myAddress, communicationManager) {
      this.storageEngine = storageEngine;
      this.cacheEngine = cacheEngine;
      this.modelEngine = modelEngine;
      this.myAddress = myAddress;
      this.communicationManager = communicationManager;
      this.removeSomething = bind(this.removeSomething, this);
      this._setSomething = bind(this._setSomething, this);
      this._getSomething = bind(this._getSomething, this);
      this.createNewZone = bind(this.createNewZone, this);
      this.resolveZoneFor = bind(this.resolveZoneFor, this);
      this.lookupZone = bind(this.lookupZone, this);
      this.registerZone = bind(this.registerZone, this);
      this.setAndPersistTiles = bind(this.setAndPersistTiles, this);
      this.setTileAt = bind(this.setTileAt, this);
      this.getTileAt = bind(this.getTileAt, this);
      this.getEntityAt = bind(this.getEntityAt, this);
      this.getItemAt = bind(this.getItemAt, this);
      this.updateEntity = bind(this.updateEntity, this);
      this.removeEntity = bind(this.removeEntity, this);
      this.addEntity = bind(this.addEntity, this);
      this.createEntity = bind(this.createEntity, this);
      this.updateItem = bind(this.updateItem, this);
      this.removeItem = bind(this.removeItem, this);
      this.addItem = bind(this.addItem, this);
      this.createItem = bind(this.createItem, this);
      this.onSiblingUpdate = bind(this.onSiblingUpdate, this);
      this.persistDirtyZones = bind(this.persistDirtyZones, this);
      this.onZoneEvicted = bind(this.onZoneEvicted, this);
      this.dirtyZones = {};
      this.zoneUnderConstruction = {};
      this.postContructionCallbacks = {};
      this.zones = new lru(lruopts);
      this.zoneItemQuadTrees = {};
      this.zoneEntityQuadTrees = {};
      this.zoneTiles = {};
      this.zones.on('evict', this.onZoneEvicted);
      this.communicationManager.registerForUpdates(this.myAddress, this.onSiblingUpdate);
      this.siblings = new Siblings(this.myAddress, this.communicationManager, this.cacheEngine, this.modelEngine);
    }

    Tiler.prototype.onZoneEvicted = function(zoneObj) {
      return this.siblings.deRegisterAsSiblingForZone(zoneObj);
    };

    Tiler.prototype.persistDirtyZones = function() {
      var a, b, count, howmany, k, q, ref, ref1, zone;
      q = defer();
      count = 0;
      ref = this.dirtyZones;
      for (a in ref) {
        b = ref[a];
        count++;
      }
      howmany = count;
      console.log('Tiler.persistDirtyZones persisting ' + count + ' zones');
      if (count === 0) {
        q.resolve(0);
      }
      ref1 = this.dirtyZones;
      for (k in ref1) {
        zone = ref1[k];
        zone.serialize().then((function(_this) {
          return function() {
            if (--count === 0) {
              _this.dirtyZones = {};
              return q.resolve(howmany);
            }
          };
        })(this));
      }
      return q;
    };

    Tiler.prototype.onSiblingUpdate = function(_command, cb) {
      var arg1, arg2, command;
      command = JSON.parse(_command);
      arg1 = command.arg1;
      arg2 = command.arg2;
      switch (command.cmd) {
        case Siblings.CMD_SET_TILE:
          return this.setTileAt(arg1, arg2, true);
        case Siblings.CMD_ADD_ITEM:
          return this.addItem(arg1, arg2, true);
        case Siblings.CMD_REMOVE_ITEM:
          return this.removeItem(arg1, arg2, true);
        case Siblings.CMD_UPDATE_ITEM:
          return this.updateItem(arg1, arg2, true);
        case Siblings.CMD_ADD_ENTITY:
          return this.addEntity(arg1, arg2, true);
        case Siblings.CMD_REMOVE_ENTITY:
          return this.removeEntity(arg1, arg2, true);
        case Siblings.CMD_UPDATE_ENTITY:
          return this.updateEntity(arg1, arg2, true);
        case Siblings.CMD_GET_OPLOG:
          return this.siblings.getOplog(command, cb);
        case Siblings.CMD_NEW_OPLOG_EPOCH:
          return this.siblings.newOplogEpoch(command, cb);
      }
    };

    Tiler.prototype.createItem = function(level, itemRecord) {
      var q;
      q = defer();
      if (!level || !itemRecord || !itemRecord.x || !itemRecord.y) {
        q.reject('Tiler.createItem got bad item!!');
      } else {
        this.modelEngine.createItem(itemRecord).then((function(_this) {
          return function(itemObj) {
            itemObj.serialize();
            _this.addItem(level, itemObj);
            return q.resolve(itemObj);
          };
        })(this));
      }
      return q;
    };

    Tiler.prototype.addItem = function(level, item, doNotPropagate) {
      var q;
      q = defer();
      this._setSomething(level, item, this.zoneItemQuadTrees, 'items', q).then((function(_this) {
        return function(zoneObj) {
          if (!doNotPropagate) {
            return _this.siblings.sendCommand(zoneObj, Siblings.CMD_ADD_ITEM, level, item);
          }
        };
      })(this));
      return q;
    };

    Tiler.prototype.removeItem = function(level, item, doNotPropagate) {
      var q;
      q = defer();
      this.removeSomething(level, item, this.zoneItemQuadTrees, 'items', q).then((function(_this) {
        return function(zoneObj) {
          if (!doNotPropagate) {
            return _this.siblings.sendCommand(zoneObj, Siblings.CMD_REMOVE_ITEM, level, item);
          }
        };
      })(this));
      return q;
    };

    Tiler.prototype.updateItem = function(level, item, doNotPropagate) {
      if (!doNotPropagate) {
        this.siblings.sendCommand(zoneObj, Siblings.CMD_UPDATE_ITEM, level, item);
      }
      return this.modelEngine.updateObject(item);
    };

    Tiler.prototype.createEntity = function(level, entityRecord) {
      var q;
      q = defer();
      if (!entity || !entityRecord || !entityRecord.x || !entityRecord.y) {
        q.reject('Tiler.createEntity got bad entity!!');
      } else {
        this.modelEngine.createEntity(entityRecord).then((function(_this) {
          return function(entityObj) {
            entityObj.serialize();
            _this.addEntity(level, entityObj);
            return q.resolve(entityObj);
          };
        })(this));
      }
      return q;
    };

    Tiler.prototype.addEntity = function(level, entity, doNotPropagate) {
      var q;
      q = defer();
      this._setSomething(level, entity, this.zoneEntityQuadTrees, 'entities', q).then((function(_this) {
        return function(zoneObj) {
          if (!doNotPropagate) {
            return _this.siblings.sendCommand(zoneObj, Siblings.CMD_ADD_ENTITY, level, entity);
          }
        };
      })(this));
      return q;
    };

    Tiler.prototype.removeEntity = function(level, entity, doNotPropagate) {
      var q;
      q = defer();
      this.removeSomething(level, entity, this.zoneEntityQuadTrees, 'entities', q).then((function(_this) {
        return function(zoneObj) {
          if (!doNotPropagate) {
            return _this.siblings.sendCommand(zoneObj, Siblings.CMD_REMOVE_ENTITY, level, entity);
          }
        };
      })(this));
      return q;
    };

    Tiler.prototype.updateEntity = function(level, entity, doNotPropagate) {
      if (!doNotPropagate) {
        this.siblings.sendCommand(zoneObj, Siblings.CMD_UPDATE_ENTITY, level, entity);
      }
      return this.modelEngine.updateObject(entity);
    };

    Tiler.prototype.getItemAt = function(level, x, y) {
      var q;
      q = defer();
      if (!level || (!x && x !== 0) || (!y && y !== 0)) {
        q.reject('Tiler.getTileAt got wrong parameters ');
      } else {
        this._getSomething(level, x, y, this.zoneItemQuadTrees, q);
      }
      return q;
    };

    Tiler.prototype.getEntityAt = function(level, x, y) {
      var q;
      q = defer();
      if (!level || (!x && x !== 0) || (!y && y !== 0)) {
        q.reject('Tiler.getTileAt got wrong parameters ');
      } else {
        this._getSomething(level, x, y, this.zoneEntityQuadTrees, q);
      }
      return q;
    };

    Tiler.prototype.getTileAt = function(level, x, y) {
      var q;
      q = defer();
      if (!level || (!x && x !== 0) || (!y && y !== 0)) {
        q.reject('Tiler.getTileAt wrong parameters ');
      } else {
        this.resolveZoneFor(level, x, y).then((function(_this) {
          return function(zone) {
            var tile, ztiles;
            if (zone && zone.tileid) {
              ztiles = _this.zoneTiles[zone.tileid];
              tile = ztiles[x + '_' + y];
              return q.resolve(tile);
            } else {
              return q.resolve(BAD_TILE);
            }
          };
        })(this), function() {
          console.log('getTileAt got reject from resolveZoneFor for level ' + level + ' x ' + x + ' y ' + y);
          return q.reject('could not resolve zone tileid for ' + (arguments.join('_')));
        });
      }
      return q;
    };

    Tiler.prototype.setTileAt = function(level, tile, doNotPropagate) {
      var q, x, y;
      q = defer();
      if (!tile || (tile && !tile.type && tile.type !== 0) || (!tile.x && tile.x !== 0) || (!tile.y && tile.y !== 0)) {
        q.reject("bad tile format");
      } else {
        x = tile.x;
        y = tile.y;
        this.resolveZoneFor(level, x, y).then((function(_this) {
          return function(zone) {
            var found, i, j, len, oldtile, ref, ztiles;
            ztiles = _this.zoneTiles[zone.tileid] || [];
            ztiles[x + '_' + y] = tile;
            _this.zoneTiles[zone.tileid] = ztiles;
            found = false;
            ref = zone.tiles;
            for (oldtile = j = 0, len = ref.length; j < len; oldtile = ++j) {
              i = ref[oldtile];
              if (oldtile.x === x && oldtile.y === y) {
                zone.tiles.splice(i, 1, tile);
                found = true;
                break;
              }
            }
            if (!found) {
              zone.tiles.push(tile);
            }
            _this.dirtyZones[zone.tileid] = zone;
            if (!doNotPropagate) {
              _this.siblings.sendCommand(zone, Siblings.CMD_SET_TILE, level, tile);
            }
            return q.resolve(tile);
          };
        })(this));
      }
      return q;
    };

    Tiler.prototype.setAndPersistTiles = function(level, tiles) {
      var count, error, q, success, tileOps, zonesAffected;
      q = defer();
      count = tiles.length;
      zonesAffected = {};
      tileOps = [];
      error = function(err) {
        console.log('setAndPersistTiles error: ' + err);
        return q.reject(err);
      };
      success = function(tiles) {
        var k, v;
        for (k in zonesAffected) {
          v = zonesAffected[k];
          v.serialize();
        }
        return q.resolve(tiles);
      };
      tiles.forEach((function(_this) {
        return function(tile) {
          return _this.resolveZoneFor(level, tile.x, tile.y).then(function(zone) {
            zonesAffected[zone.id] = zone;
            tileOps.push(_this.setTileAt(level, tile));
            if (--count === 0) {
              return all(tileOps, error).then(success, error);
            }
          });
        };
      })(this));
      return q;
    };

    Tiler.prototype.registerZone = function(q, zoneObj) {
      var arr, entityQT, itemQT, x, y, ztiles;
      arr = zoneObj.tileid.split('_');
      x = arr[1];
      y = arr[2];
      itemQT = new QuadTree({
        x: x,
        y: y,
        height: TILE_SIDE,
        width: TILE_SIDE
      });
      this.zoneItemQuadTrees[zoneObj.tileid] = itemQT;
      zoneObj.items.forEach((function(_this) {
        return function(item) {
          return _this._setSomething(level, item, itemQT, 'items', q, true).then(function(zo) {});
        };
      })(this));
      entityQT = new QuadTree({
        x: x,
        y: y,
        height: TILE_SIDE,
        width: TILE_SIDE
      });
      this.zoneEntityQuadTrees[zoneObj.tileid] = entityQT;
      zoneObj.entities.forEach((function(_this) {
        return function(entity) {
          return _this._setSomething(level, entity, entityQT, 'entities', q, true).then(function(zo) {});
        };
      })(this));
      ztiles = this.zoneTiles[zoneObj.tileid] || {};
      zoneObj.tiles.forEach((function(_this) {
        return function(tile) {
          return ztiles[tile.x + '_' + tile.y] = tile;
        };
      })(this));
      this.zoneTiles[zoneObj.tileid] = ztiles;
      if (debug) {
        console.log('registerZone adds item and entity QTs for tileid ' + zoneObj.tileid);
      }
      this.zones.set(zoneObj.tileid, zoneObj);
      return this.siblings.registerAsSiblingForZone(zoneObj).then((function(_this) {
        return function() {
          var cbs;
          if (debug) {
            console.log('Tiler.registerZone back in business');
          }
          if (_this.zoneUnderConstruction[zoneObj.tileid] === true) {
            delete _this.zoneUnderConstruction[zoneObj.tileid];
            cbs = _this.postContructionCallbacks[zoneObj.tileid] || [];
            cbs.forEach(function(cb) {
              if (debug) {
                console.log('<------ resolving paused lookup of zone');
              }
              return cb();
            });
            if (debug) {
              console.log('Tiler.registerZone done');
            }
            return q.resolve(zoneObj);
          } else {
            if (debug) {
              console.log('Tiler.registerZone done 2');
            }
            return q.resolve(zoneObj);
          }
        };
      })(this));
    };

    Tiler.prototype.lookupZone = function(tileid, q) {
      var lruZone;
      if (debug) {
        console.log('lookupZOne called for ' + tileid);
      }
      lruZone = this.zones.get(tileid);
      if (lruZone) {
        if (debug) {
          console.log('resolving ' + tileid + ' from lru');
        }
        return q.resolve(lruZone);
      } else {
        this.zoneUnderConstruction[tileid] = true;
        return this.cacheEngine.get(tileid).then((function(_this) {
          return function(exists) {
            if (exists) {
              return _this.storageEngine.find('Zone', 'tileid', tileid).then(function(zoneObj) {
                if (zoneObj) {
                  if (debug) {
                    console.log('resolving ' + tileid + ' from db');
                  }
                  return _this.registerZone(q, zoneObj);
                } else {
                  if (debug) {
                    console.log('** Tiler Could not find supposedly existing zone ' + tileid + ' !!!!!');
                  }
                  return q.reject(BAD_TILE);
                }
              });
            } else {
              if (debug) {
                console.log('zone ' + tileid + ' ****************** not found, so creating new..');
              }
              return _this.createNewZone(tileid).then(function(zoneObj) {
                return _this.registerZone(q, zoneObj);
              });
            }
          };
        })(this));
      }
    };

    Tiler.prototype.resolveZoneFor = function(level, x, y) {
      var cbs, q, tid, underConstruction;
      q = defer();
      tid = this.getZoneIdFor(level, x, y);
      underConstruction = this.zoneUnderConstruction[tid];
      if (underConstruction) {
        if (debug) {
          console.log('------> waiting for zone construction for ' + tid);
        }
        cbs = this.postContructionCallbacks[tid] || [];
        cbs.push((function(_this) {
          return function() {
            return _this.lookupZone(tid, q);
          };
        })(this));
        this.postContructionCallbacks[tid] = cbs;
      } else {
        this.lookupZone(tid, q);
      }
      return q;
    };

    Tiler.prototype.createNewZone = function(tileid) {
      var newzone, q;
      q = defer();
      newzone = {
        name: 'Zone_' + tileid,
        type: 'Zone',
        id: tileid,
        tileid: tileid,
        items: [],
        entities: [],
        tiles: []
      };
      this.modelEngine.createZone(newzone).then((function(_this) {
        return function(zoneObj) {
          zoneObj.serialize();
          _this.zones.set(tileid, zoneObj);
          return _this.cacheEngine.set(tileid, 1).then(function() {
            return q.resolve(zoneObj);
          });
        };
      })(this));
      return q;
    };

    Tiler.prototype._getSomething = function(level, x, y, qthash, q) {
      return this.resolveZoneFor(level, x, y).then((function(_this) {
        return function(zoneObj) {
          var qt, something;
          if (zoneObj) {
            qt = qthash[zoneObj.tileid];
            something = qt.retrieve({
              x: x,
              y: y
            });
            return q.resolve(something[0]);
          }
        };
      })(this), function() {
        console.log('_getSomething got reject from resolveZoneFor for level ' + level + ' x ' + x + ' y ' + y);
        return q.reject('could not resolve zone tileid for ' + (arguments.join('_')));
      });
    };

    Tiler.prototype._setSomething = function(level, something, qthash, propname, q, skipadd) {
      var qq;
      qq = defer();
      this.resolveZoneFor(level, something.x, something.y).then((function(_this) {
        return function(zoneObj) {
          var found, i, j, len, qt, stuff, what;
          if (zoneObj) {
            qt = qthash[zoneObj.tileid];
            qt.insert(something);
            if (!skipadd) {
              stuff = zoneObj[propname];
              for (i = j = 0, len = stuff.length; j < len; i = ++j) {
                what = stuff[i];
                if (what.id === something.id) {
                  found = true;
                  stuff[i] = something;
                }
              }
              if (!found) {
                stuff.push(something);
              }
              _this.dirtyZones[zoneObj.tileid] = zoneObj;
            }
            q.resolve(true);
            return qq.resolve(zoneObj);
          }
        };
      })(this), function() {
        console.log('_setSomething got reject from resolveZoneFor for level ' + level + ' x ' + x + ' y ' + y);
        q.reject('could not resolve zone tileid for level ' + level + ' and something ' + something.type + ' ' + something.id);
        return qq.resolve(false);
      });
      return qq;
    };

    Tiler.prototype.removeSomething = function(level, something, qthash, propname, q) {
      var qq;
      qq = defer();
      this.resolveZoneFor(level, something.x, something.y).then((function(_this) {
        return function(zoneObj) {
          var i, index, j, len, qt, stuff, what;
          if (zoneObj) {
            qt = qthash[zoneObj.tileid];
            qt.remove(something);
            _this.dirtyZones[zoneObj.tileid] = zoneObj;
            stuff = zoneObj[propname];
            index = -1;
            for (i = j = 0, len = stuff.length; j < len; i = ++j) {
              what = stuff[i];
              if (what.id === something.id) {
                index = i;
                break;
              }
            }
            if (index > -1) {
              stuff.splice(index, 1);
            }
            q.resolve(true);
            return qq.resolve(zoneObj);
          }
        };
      })(this), function() {
        console.log('removeSomething got reject from resolveZoneFor for level ' + level + ' x ' + x + ' y ' + y);
        return q.reject('could not resolve zone tileid for level ' + level + ' and something ' + something.type + ' ' + something.id);
      });
      return qq;
    };

    Tiler.prototype.getZoneIdFor = function(level, x, y) {
      var xr, yr, zx, zy;
      xr = x % TILE_SIDE;
      yr = y % TILE_SIDE;
      zx = x - xr;
      zy = y - yr;
      return level + '_' + zx + '_' + zy;
    };

    return Tiler;

  })();

  module.exports = Tiler;

}).call(this);

//# sourceMappingURL=Tiler.js.map
